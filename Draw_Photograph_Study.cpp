#include <iostream>
#include <stdlib.h>
#include <cstdio>
#include <easyx.h> //包含easyx图形库
using namespace std;
void Draw_Photograph()
{
    // 定义图片变量来存储图片
    IMAGE img;
    // 加载图片
    loadimage(&img, "Image\\154636-174228399681ff.jpg");
    /*
        第一个参数是pDstImg
            保存图像的IMAGE对象指针。如果为 NULL，表示图片将读取至绘图窗口。
            用于加载IMAGE对象指针里的图片
        第二个参数是pImgFile
            图片文件名，支持 bmp / gif / jpg / png / tif / emf / wmf / ico 格式的图片。gif 格式的图片仅加载第一帧；gif 与 png 均不支持透明。
            就是路径
            路径：绝对路径：绝对路径就是带盘符的，例：E:\Programming\C++\StudyEasyx\Image\154636-174228399681ff.jpg
                  相对路径:就是项目所在的目录，例：Image\154636-174228399681ff.jpg 就是当前项目或工程目录下的Image文件夹下的154636-174228399681ff.jpg图片
        第三个参数是nWidth
            图片的拉伸宽度，加载图片后，会拉伸至该宽度。如果为 0，表示使用原图的宽度。
        第四个参数是nHeight
            图片的拉伸高度，加载图片后，会拉伸至该高度。如果为 0，表示使用原图的高度。
        第五个参数是bResize
            是否调整IMAGE的大小以适应图片，大小以适应某些需求（例如窗口大小或显示区域）
            注意事项:
                字符串中的文件名路径需要使用双反斜杠 \\ 或单斜杠 /，以避免转义字符问题。
                字符串是区分大小写的。
    */
    // 输出图片
    putimage(0, 0, &img);
    /*
        第一个参数是输出图片的坐标，就是图片的左上角坐标在图形窗口的位置
        第二个参数是你要输出的图片的IMAGE指针，也就是IMAGE指针里存储的图片
        如果我们要把窗口大小和图片图片大小一样，我们可以右击图片->属性->详细信息找到图片的宽度和高度
    */
    /*
        使用掩码贴图实现透明贴图
        原理：  掩码图：黑色区域（RGB(0, 0, 0)）为透明区域。
                        白色区域（RGB(255, 255, 255))为不透明区域。
                如果:掩码的一个像素点是黑色
                     背景的一个像素点是红色
                     原图是白色
                     结果：用背景色替换原图
                如果:掩码的一个像素点是白色
                     背景的一个像素点是红色
                     原图是蓝色
                     结果：用原图替换背景色
        例如：putimage(50, 50, &place_mask,NOTSRCERASE);以NOTSRCERASE图片模式输出掩码图              
              putimage(200, 50, &place,SRCINVERT);以SRCINVERT图片模式输出原图         
    */
    IMAGE place;                                 // 定义存储飞机的原图变量
    IMAGE place_mask;                            // 定义存储飞机掩码图的变量
    loadimage(&place, "Image\\me212.png");       // 加载飞机的原图，并保存到 place变量的地址中
    loadimage(&place_mask, "Image\\me2222.png"); // 加载飞机的掩码图，并保存到place_mask变量的地址中
    putimage(50, 50, &place_mask,NOTSRCERASE);//输出掩码图 
    putimage(50, 50, &place,SRCINVERT);//输出原图    
}
int main()
{
    initgraph(656, 503, EX_SHOWCONSOLE); // 创建一个800*800的窗口,并显示控制台
    /*
        EX_DBLCLKS 在绘图窗口中支持鼠标双击事件。
        EX_NOCLOSE 禁用绘图窗口的关闭按钮。
        EX_NOMINIMIZE 禁用绘图窗口的最小化按钮。
        EX_SHOWCONSOLE 显示控制台窗口。
    */
    /*
        如果三个都需要设置，可以使用按位或操作连接起来
        EX_NOMINIMIZE | EX_NOCLOSE | EX_SHOWCONSOLE
    */
    setbkcolor(WHITE); // 设置窗口的背景颜色，
    /*
        我们的颜色是由RGB组成的，也就是三原色
        如果没有你喜欢的颜色，我可以使用带参宏来实现
        setbkcolor(RGB(41, 29, 55))
    */
    cleardevice(); // 这个函数使用当前背景色清空绘图设备。
    // 窗口的坐标体系，左上角坐标原点，x轴向增大，y轴向下增大
    Draw_Photograph(); // 绘制照片
    system("pause");   // 防止窗口一闪而过,闪退
    closegraph();      // 关闭绘图窗口
    return 0;
}
/*
好的！下面通过一个具体的计算例子来说明 **EasyX 掩码贴图** 的实现过程。我们将模拟掩码图和原图的像素操作，展示如何通过掩码图实现透明效果。
---
### **示例场景**
假设我们有以下图像：
1. **背景图**：纯蓝色背景（`RGB(0, 0, 255)`）。
2. **掩码图**：一个 3x3 的黑白二值图，黑色表示透明区域，白色表示非透明区域。
3. **原图**：一个 3x3 的彩色图，包含一些颜色像素。
---
### **图像数据**
#### 1. 掩码图（Mask Image）
掩码图是一个 3x3 的黑白二值图，黑色（`RGB(0, 0, 0)`）表示透明区域，白色（`RGB(255, 255, 255)`）表示非透明区域。
```
掩码图像素值：
[ (0,0,0), (255,255,255), (0,0,0) ]
[ (255,255,255), (255,255,255), (255,255,255) ]
[ (0,0,0), (255,255,255), (0,0,0) ]
```
#### 2. 原图（Source Image）
原图是一个 3x3 的彩色图，包含一些颜色像素。
```
原图像素值：
[ (255,0,0), (0,255,0), (0,0,255) ]
[ (255,255,0), (255,0,255), (0,255,255) ]
[ (128,128,128), (64,64,64), (192,192,192) ]
```
#### 3. 背景图（Background Image）
背景图是一个纯蓝色背景（`RGB(0, 0, 255)`）。
```
背景图像素值：
[ (0,0,255), (0,0,255), (0,0,255) ]
[ (0,0,255), (0,0,255), (0,0,255) ]
[ (0,0,255), (0,0,255), (0,0,255) ]
```
---
### **掩码贴图的计算过程**
我们将遍历每个像素，根据掩码图的值决定是否用原图的像素替换背景图的像素。
#### 计算规则：
1. 如果掩码图的像素是白色（`RGB(255,255,255)`），则用原图的像素替换背景图的像素。
2. 如果掩码图的像素是黑色（`RGB(0,0,0)`），则保留背景图的像素。
---
#### **逐像素计算**
我们以 `(x, y)` 表示像素坐标，从 `(0, 0)` 到 `(2, 2)` 遍历每个像素。
1. **像素 (0, 0)**：
   - 掩码图值：`(0,0,0)`（黑色，透明）
   - 原图值：`(255,0,0)`
   - 背景图值：`(0,0,255)`
   - 结果：保留背景图值 `(0,0,255)`。
2. **像素 (1, 0)**：
   - 掩码图值：`(255,255,255)`（白色，非透明）
   - 原图值：`(0,255,0)`
   - 背景图值：`(0,0,255)`
   - 结果：用原图值替换背景图值 `(0,255,0)`。
3. **像素 (2, 0)**：
   - 掩码图值：`(0,0,0)`（黑色，透明）
   - 原图值：`(0,0,255)`
   - 背景图值：`(0,0,255)`
   - 结果：保留背景图值 `(0,0,255)`。
4. **像素 (0, 1)**：
   - 掩码图值：`(255,255,255)`（白色，非透明）
   - 原图值：`(255,255,0)`
   - 背景图值：`(0,0,255)`
   - 结果：用原图值替换背景图值 `(255,255,0)`。
5. **像素 (1, 1)**：
   - 掩码图值：`(255,255,255)`（白色，非透明）
   - 原图值：`(255,0,255)`
   - 背景图值：`(0,0,255)`
   - 结果：用原图值替换背景图值 `(255,0,255)`。
6. **像素 (2, 1)**：
   - 掩码图值：`(255,255,255)`（白色，非透明）
   - 原图值：`(0,255,255)`
   - 背景图值：`(0,0,255)`
   - 结果：用原图值替换背景图值 `(0,255,255)`。
7. **像素 (0, 2)**：
   - 掩码图值：`(0,0,0)`（黑色，透明）
   - 原图值：`(128,128,128)`
   - 背景图值：`(0,0,255)`
   - 结果：保留背景图值 `(0,0,255)`。
8. **像素 (1, 2)**：
   - 掩码图值：`(255,255,255)`（白色，非透明）
   - 原图值：`(64,64,64)`
   - 背景图值：`(0,0,255)`
   - 结果：用原图值替换背景图值 `(64,64,64)`。
9. **像素 (2, 2)**：
   - 掩码图值：`(0,0,0)`（黑色，透明）
   - 原图值：`(192,192,192)`
   - 背景图值：`(0,0,255)`
   - 结果：保留背景图值 `(0,0,255)`。
---
### **最终结果**
经过掩码贴图处理后，最终的图像像素值为：
```
[ (0,0,255), (0,255,0), (0,0,255) ]
[ (255,255,0), (255,0,255), (0,255,255) ]
[ (0,0,255), (64,64,64), (0,0,255) ]
```
---
### **结果分析**
- 掩码图中黑色区域（透明区域）保留了背景图的蓝色像素。
- 掩码图中白色区域（非透明区域）用原图的像素替换了背景图的像素。

---
### **总结**
通过这个计算例子，我们可以看到掩码贴图的核心原理：
1. 掩码图定义了透明和非透明区域。
2. 通过逐像素操作，将原图的非透明区域绘制到背景图上。
3. 透明区域保留背景图的原始内容。
这种方法简单直观，适合实现透明效果或图像合成。
*/